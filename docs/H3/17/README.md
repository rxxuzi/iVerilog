# Verilogを用いたハードウェアシミュレーション・モデル

## 概要
Verilogを用いたハードウェアシミュレーション・モデルは、ハードウェアの設計段階で非常に重要な役割を果たす。これらのモデルは、実際の物理的デバイスを製造する前に、デザインのテストや検証を行うために使用される。このプロセスは、設計上の誤りを早期に発見し、修正することができるため、コストと時間を節約する上で効果的である。

## シミュレーション記述概要（ディジタル設計講義より）
シミュレーション記述は、検証用トップモジュールにおいて、検証対象回路以外の部分を指す。入力と出力の記述、イベントの処理、タイミング制御などが主要な要素となる。シミュレーションの流れはHDL（Hardware Description Language）の特性上、時刻順に進行し、複数の回路が同時に動作するように見える。ステートメント（for文、while文、repeat文など）を使用して、シミュレーションの挙動を制御する。

以下は、Verilogを用いたハードウェアシミュレーションモデルに関連する情報である。

### シミュレーションの入力記述
- `initial` 文を使って入力を与える。
- タスクによる入力：検証対象回路への入力をタスクを用いて与える。多くのタスクを作成し、タスクを呼び出すことで検証入力が簡潔になる。
- 入力パターン：外部ファイルから入力パターンを読み込み、1クロックごとに入力に印加する。

### シミュレーションの出力記述
- `$monitor`：信号の変化がある時のみ出力。`initial` 文内で1回記述。
- `$display`：呼び出された時のみ実行。`always` 文を用いて繰り返し表示。
- `$dumpfile`：ダンプファイルの名前指定。
- `$dumpvars`：ダンプを取る対象指定。

### 論理合成後のシミュレーション
- RTLで記述された回路は論理合成によりASICやFPGAのネットリストに変換される。
- ゲート遅延を含んだゲートレベルシミュレーションを行うためのライブラリが必要。

### シミュレーションの流れ
- HDLとプログラム言語の違いは時間の概念にある。
- HDLは時刻の順序で動作するため、複数の回路が同時に動作するように見える。

### モジュール・アイテムとステートメント
- モジュール・アイテムには`if`文や`case`文などのステートメントは記述できない。
- ステートメントは`initial`, `always`, `function`, `task` の各構文中でのみ使用可能。

### initial文とalways文
- `initial` 文：シミュレーション開始後1度だけ実行。論理合成対象外。
- `always` 文：繰り返し実行される。

この情報は、Verilogのシミュレーションにおける基本的な概念や方法論を理解するのに役立つ。シミュレーションの入力や出力の扱い方、タイムラインに沿ったシミュレーションの進行、論理合成後の振る舞いなど、Verilogにおける重要な要素が含まれている。

## 概要

### beginend_tp.v シミュレーション・モデル
このモデルは、基本的な初期化とシミュレーションの進行を示している。信号の値が時間と共にどのように変化するかを観察するために用いられる。

```verilog
module beginend_tp;

reg A, B, C;

parameter STEP = 1000;

initial begin
    A=0; B=1; C=0;
    #50 A=1;
    #50 A=0; C=1;
    #50 B=0;
    #50 $finish;
end

initial $monitor($stime, " A=%b B=%b C=%b", A, B, C);

endmodule
```

### forkjoin_tp.v シミュレーション・モデル
`fork ... join`構造を用いて、複数のプロセスを並行して実行する方法を示している。この方式は、同時に発生するイベントやプロセスのシミュレーションに適している。

```verilog
module forkjoin_tp;

reg A, B, C;

parameter STEP = 1000;

initial fork
    A=0; B=1; C=0;
    #50 A=1;
    #100 A=0;
    #100 C=1;
    #150 B=0;
    #200 $finish;
join

initial $monitor($stime, " A=%b B=%b C=%b", A, B, C);

endmodule
```

### inpattern_tp.v シミュレーション・モデル
このモデルは、外部ファイル（`inpattern.dat`）からの入力パターンを読み込み、それをモジュール内で使用する。これにより、複雑な入力シーケンスを簡単に管理し、シミュレーションに適用することができる。

```verilog
module inpattern_tp;

reg [1:0] ADDR;
reg [7:0] DIN;
reg REB, WEB;
reg [11:0] pat, pattern[0:3];
integer i;

parameter STEP = 1000;

initial begin
    $readmemb("inpattern.dat", pattern);
    ADDR=0; DIN=0; REB=0; WEB=0;
    for(i=0; i<4; i

=i+1) begin
        pat=pattern[i];
        #STEP ADDR=pat[11:10];
              DIN=pat[9:2];
              REB=pat[1];
              WEB=pat[0];
    end
    #STEP $finish;
end

initial $monitor($stime, " ADDR=%h DIN=%h REB=%b WEB=%b", ADDR, DIN, REB, WEB);

endmodule
```

## まとめ
これらのモデルは、Verilogを用いたハードウェアのシミュレーションにおいて基本的なテクニックを示している。初期化、信号の変化、並行プロセス、外部データの読み込みなど、シミュレーションの多様な側面をカバーしている。これにより、設計者はハードウェアの動作をより正確に理解し、検証することができる。